<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="initial-scale=1,maximum-scale=1,user-scalable=no"
    />
    <title>Nine Colors</title>
    <style> 
      html,
      body,
      #viewDiv {
        padding: 0;
        margin: 0;
        height: 100%;
        width: 100%;
      }

      #formDiv {
        width: 100%;
      }

      .esri-item-list__scroller {
        overflow-y: visible;
      }

      .editArea-container {
        background: #fff;
        line-height: 1.5em;
        overflow: auto;
        padding: 12px 15px;
        width: 300px;
      }

      .list-heading {
        font-weight: normal;
        margin-top: 20px;
        margin-bottom: 10px;
        color: #323232;
      }

      .or-wrap {
        background-color: #e0e0e0;
        height: 1px;
        margin: 2em 0;
        overflow: visible;
      }

      .or-text {
        background: #fff;
        line-height: 0;
        padding: 0 1em;
        position: relative;
        bottom: 0.75em;
      }

      /* override default styles */
      .esri-feature-form {
        background: #fff;
      }

      .esri-feature-templates {
        width: 256px;
      }

      .esri-feature-templates__section-header {
        display: none;
      }

      .esri-feature-templates__section {
        box-shadow: none;
      }

      .esri-feature-templates__scroller {
        max-height: 200px;
      }


      .esri-ui-top-right {
        max-height: 100%;
      }

      #queryDiv,
      #resultDiv {
        min-width: 250px;
        font-size: 14px;
        padding: 10px;
        display: none;
        overflow-y: auto;
        overflow-x: hidden;
      }

      .geometry-options {
        display: flex;
        flex-direction: row;
      }
      .geometry-button {
        flex: 1;
        border-style: solid;
        border-width: 1px;
        border-image: none;
      }
      .geometry-button-selected {
        background: #4c4c4c;
        color: #fff;
      }

      #bufferNum {
        width: 90%;
        margin: 2.5em auto 0;
      }

      .count {
        white-space: nowrap;
        font-size: 14px;
        font-weight: bold;
        display: inline-block;
      }

      #sketchPanel {
        padding: 10px;
        background-color: rgba(255, 255, 255, 0.8);
      }

      .esri-button {
        margin: 2px;
      }

      #infoDiv {
        background-color: white;
        color: black;
        padding: 6px;
        width: 250px;
      }

      #results {
        font-weight: bolder;
        padding-top: 10px;
      }
      .slider {
        width: 100%;
        height: 60px;
        padding-top: 20px;
      }
    </style>
    <!-- Load the Chart.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.8.0/Chart.min.js"></script>

    <link
      rel="stylesheet"
      href="https://js.arcgis.com/4.14/esri/themes/light/main.css"
    />
    <script src="https://js.arcgis.com/4.14/"></script>

    <script>
      // require([
      //   "esri/WebScene",
      //   "esri/views/SceneView",
      //   "esri/layers/GraphicsLayer",
      //   "esri/widgets/Sketch/SketchViewModel",
      //   "esri/widgets/Slider",
      //   "esri/geometry/geometryEngine",
      //   "esri/Graphic",
      //   "esri/core/promiseUtils"
      // ], function(
      //   WebScene,
      //   SceneView,
      //   GraphicsLayer,
      //   SketchViewModel,
      //   Slider,
      //   geometryEngine,
      //   Graphic,
      //   promiseUtils
      // ) {

        require([
        "esri/Map",
        "esri/layers/GeoJSONLayer",
        "esri/symbols/PolygonSymbol3D",
        "esri/symbols/ExtrudeSymbol3DLayer",
        "esri/renderers/SimpleRenderer",
        "esri/widgets/Legend",
        "esri/WebScene",
        "esri/views/SceneView",
        "esri/layers/GraphicsLayer",
        "esri/widgets/Sketch/SketchViewModel",
        "esri/widgets/Slider",
        "esri/views/layers/support/FeatureFilter",
        "esri/geometry/geometryEngine",
        "esri/Graphic",
        "esri/core/promiseUtils",
        "esri/layers/GraphicsLayer",
        "esri/symbols/WebStyleSymbol",
        "esri/widgets/Editor",
        "esri/layers/FeatureLayer",
        "esri/widgets/LayerList",
        "esri/widgets/Expand",
        "esri/widgets/FeatureForm",
        "esri/widgets/FeatureTemplates",
        "dojo/request",
        "esri/symbols/WebStyleSymbol"    
      ], function(
        Map,
        GeoJSONLayer,PolygonSymbol3D,ExtrudeSymbol3DLayer, SimpleRenderer,Legend,
        WebScene,
        SceneView,
        GraphicsLayer,
        SketchViewModel,
        Slider,
        FeatureFilter,
        geometryEngine,
        Graphic,
        promiseUtils,
        GraphicsLayer,
        WebStyleSymbol,
        Editor,
        FeatureLayer, 
        LayerList,
        Expand,
        FeatureForm,
        FeatureTemplates,
        request,
        WebStyleSymbol
      ) {
        const url ="data/bronx_pluto.json";
        let editFeature, highlight;
 
        var resSym = {
          type: "polygon-3d", // autocasts as new PolygonSymbol3D()
          symbolLayers: [
            {
              type: "extrude", // autocasts as new ExtrudeSymbol3DLayer()
              material: {
                color: "#FDB809"
              },
              edges: {
                type: "solid",
                color: "#72420d",
                size: 1.5
              }
            }
          ]
        };
        var comSym = {
          type: "polygon-3d", // autocasts as new PolygonSymbol3D()
          symbolLayers: [
            {
              type: "extrude", // autocasts as new ExtrudeSymbol3DLayer()
              material: {
                color: "#F3BEB1"
              },
              edges: {
                type: "solid",
                color: "#72420d",
                size: 1.5
              }
            }
          ]
        };
        var offSym = {
          type: "polygon-3d", // autocasts as new PolygonSymbol3D()
          symbolLayers: [
            {
              type: "extrude", // autocasts as new ExtrudeSymbol3DLayer()
              material: {
                color: "#E01B27"
              },
              edges: {
                type: "solid",
                color: "#72420d",
                size: 1.5
              }
            }
          ]
        };
        var mixSym = {
          type: "polygon-3d", // autocasts as new PolygonSymbol3D()
          symbolLayers: [
            {
              type: "extrude", // autocasts as new ExtrudeSymbol3DLayer()
              material: {
                color: "#FC8553"
              },
              edges: {
                type: "solid",
                color: "#4c294b",
                size: 1.5
              }
            }
          ]
        };

        var induSym = {
          type: "polygon-3d", // autocasts as new PolygonSymbol3D()
          symbolLayers: [
            {
              type: "extrude", // autocasts as new ExtrudeSymbol3DLayer()
              material: {
                color: "#983EBC"
              },
              edges: {
                type: "solid",
                color: "#4c294b",
                size: 1.5
              }
            }
          ]
        };

        var openSym = {
          type: "polygon-3d", // autocasts as new PolygonSymbol3D()
          symbolLayers: [
            {
              type: "extrude", // autocasts as new ExtrudeSymbol3DLayer()
              material: {
                color: "#BCD08D"
              },
              edges: {
                type: "solid",
                color: "#4c294b",
                size: 1.5
              }
            }
          ]
        };

        var healthSym = {
          type: "polygon-3d", // autocasts as new PolygonSymbol3D()
          symbolLayers: [
            {
              type: "extrude", // autocasts as new ExtrudeSymbol3DLayer()
              material: {
                color: "#8bbdd9"
              },
              edges: {
                type: "solid",
                color: "#4c294b",
                size: 1.5
              }
            }
          ]
        };

        var culSym = {
          type: "polygon-3d", // autocasts as new PolygonSymbol3D()
          symbolLayers: [
            {
              type: "extrude", // autocasts as new ExtrudeSymbol3DLayer()
              material: {
                color: "#026aa7"
              },
              edges: {
                type: "solid",
                color: "#4c294b",
                size: 1.5
              }
            }
          ]
        };

        var eduSym = {
          type: "polygon-3d", // autocasts as new PolygonSymbol3D()
          symbolLayers: [
            {
              type: "extrude", // autocasts as new ExtrudeSymbol3DLayer()
              material: {
                color: "#0b54ff"
              },
              edges: {
                type: "solid",
                color: "#4c294b",
                size: 1.5
              }
            }
          ]
        };
        /*****************************************************************
         * Set each unique value directly in the renderer's constructor.
         * At least one field must be used (in this case the "DESCLU" field).
         * The label property of each unique value will be used to indicate
         * the field value and symbol in the legend.
         *
         * The size visual variable sets the height of each building as it
         * exists in the real world according to the "ELEVATION" field.
         *****************************************************************/

        var renderer = {
          type: "unique-value", // autocasts as new UniqueValueRenderer()
          defaultSymbol: {
            type: "polygon-3d", // autocasts as new PolygonSymbol3D()
            symbolLayers: [
              {
                type: "extrude", // autocasts as new ExtrudeSymbol3DLayer()
                material: {
                  color: "#0b54ff"
                },
                edges: {
                  type: "solid",
                  color: "#4d5b18",
                  size: 1.5
                }
              }
            ]
          },
          defaultLabel: "education",
          field: "BldgType",
          uniqueValueInfos: [
            {
              value: "residential",
              symbol: resSym,
              label: "residential"
            },
            {
              value: "commercial",
              symbol: comSym,
              label: "commercial"
            },
            {
              value: "office",
              symbol: offSym,
              label: "office"
            },
            {
              value: "mixed",
              symbol: mixSym,
              label: "mixed"
            },
            {
              value: "industrial",
              symbol: induSym,
              label: "industrial"
            },
            {
              value: "openspace",
              symbol: openSym,
              label: "openspace"
            },
            {
              value: "health",
              symbol: healthSym,
              label: "health"
            },
            {
              value: "cultural",
              symbol: culSym,
              label: "cultural"
            }
          ],
          visualVariables: [
            {
              type: "size",
              field: "height"
              //valueUnit: "feet" // Converts and extrudes all data values in feet
            }
          ]
        };

        const geojsonLayer = new GeoJSONLayer({
          url: url,
          copyright: "NYC Planning",
          //popupEnabled: false,
          id: "incidentsLayer",
          popupTemplate: {
            // autocasts as new PopupTemplate()
            title: "Building information",
            content: [
              {
                type: "fields",
                fieldInfos: [
                  {
                    fieldName: "BldgType",
                    label: "Building Usage"
                  },
                  {
                    fieldName: "NumFloors",
                    label: "Number of Floors"
                  },
                  {
                    fieldName: "UnitsRes",
                    label: "Residential Unit"
                  },
                  {
                    fieldName: "ResArea",
                    label: "Residential Area"
                  },
                  {
                    fieldName: "ComArea",
                    label: "Commercial Area"
                  },
                  {
                    fieldName: "OfficeArea",
                    label: "Office Area"
                  },
                  {
                    fieldName: "height",
                    label: "Height"
                  }
                ]
              }
            ]
          }, 
          outFields: ["BldgType", "UnitsRes", "height","NumFloors","ResArea","ComArea","OfficeArea"],
          renderer: renderer //optional
        });
        /********DRAW NEW BUILDINGS -1 *************/
        let gLayer = new GraphicsLayer({
            id:"gLayer"
        });
        let blue = [82, 82, 122, 0.9];
        let white = [255, 255, 255, 0.8];
    // bupolygon symbol used for sketching the extruded building footprints
        let extrudedPolygon = {
          type: "polygon-3d",
          symbolLayers: [
            {
              type: "extrude",
              //size: 10, // extrude by 10 meters
              material: {
                color: "#FC8553"
              },
              edges: {
                type: "solid",
                size: "0px",
                color: white
              }
            }
          ]
        };

        let basePolygon = {
          type: "simple-fill",
          style: "none",
          color:[0,0,0,0],
          outline: { // autocasts as new SimpleLineSymbol()
          color: [128, 128, 128, 0.5],
          width: "0px"}
        };
       /**************CREATE SCENE***************/
       var resultsLayer = new GraphicsLayer(); 
       let map = new WebScene({
          portalItem: {
            // id: "7901a1668e8d49d88f8ea2281cbf046e"
            id: "47241277f5c249d6b1c13840192a7cb0"
          },
          layers: [geojsonLayer,gLayer]
        });

        
        let view = new SceneView({
          container: "viewDiv",
          center: [-73.889946,40.830145],
          zoom: 15,
          map: map,
          camera: 
            {
                position: [-73.889946,40.830145,2000],
                tilt: 30,
                heading: 23
            }
        // highlightOptions: {
        //     color: "#00ffff",
        //     //haloColor: "yellow",
        //     haloOpacity: 0.2,
        //     fillOpacity: 0.4
        //     }
        });
        window.view = view;
        view.ui.add("infoDiv", "top-left");
      
        var legend = new Expand({
          content: new Legend({
            view: view,
            style: "classic" // other styles include 'classic'
          }),
          view: view,
          expanded: false
        });
        view.ui.add(legend, "bottom-left");
      
        // var legend = new Legend({
        //   view: view,
        //   style: "card"
        // });
        // view.ui.add(legend, "bottom-left");
        //view.ui.add("elevationDiv", "top-right");
    /********DRAW NEW BUILDINGS -2 *************/
    view.ui.add("sketchPanel", "top-right");
       
    
    
    
    let sketchGeometry_geojson = null;
        // define the SketchViewModel and pass in the symbols for each geometry type
        const sketchViewModel_geojson = new SketchViewModel({
          layer: gLayer,
          view: view,
          polygonSymbol:basePolygon,
          //polygonSymbol: extrudedPolygon,
          popupEnabled: false,
        });


        // after drawing the geometry, enter the update mode to update the geometry
        // and the deactivate the buttons
        sketchViewModel_geojson.on("create", function(event) {
          if (event.state === "complete") {
            var attributes = {
                name: "My Design",
                BldgType: "mixed",
                height:20}
//                type: event.graphic.geometry.type}
            event.graphic.attributes = attributes;
           // event.graphic.symbol = 
            // var popupTemplate = {
            //     title: "{name}",
            //     content: "I am a {type}."}
            // event.graphic.popupTemplate = popupTemplate;
            sketchViewModel_geojson.update(event.graphic);
            var edits_geojson = {addFeatures: [event.graphic]};
            applyEditsToIncidents(edits_geojson)
            //sketchGeometry_geojson = event.graphics.geometry;
          //  deactivateButtons();
          }
        });

        document
          .getElementById("drawbuilding")
          .addEventListener("click",function(event){
            sketchViewModel_geojson.create("polygon");
          });
/*
        const drawButtons = Array.prototype.slice.call(
          document.getElementsByClassName("esri-button")
          // document.getElementById("drawbuilding")
        );


        // set event listeners to activate sketching graphics
        drawButtons.forEach(function(btn) {
          btn.addEventListener("click", function(event) {
            deactivateButtons();
            //event.target.classList.add("esri-button--secondary");
            // to activate sketching the create method is called passing in the geometry type
            // from the data-type attribute of the html element
            //sketchViewModel_geojson.create(event.target.getAttribute("data-type"));
            sketchViewModel_geojson.create("polygon");

          });
        });

        function deactivateButtons() {
          drawButtons.forEach(function(element) {
            element.classList.remove("esri-button--secondary");
          });
        }

    /***********************************
    * Update and edit features
    * ********************************/
        // New FeatureForm and set its layer to 'Incidents' FeatureLayer.
        // FeatureForm displays attributes of fields specified in fieldConfig.
        const featureForm = new FeatureForm({
          container: "formDiv",
          layer: geojsonLayer,
          fieldConfig: [
            {
              name: "BldgType",
              label: "Choose building usage"
            },
            {
              name: "height",
              label: "Choose number of floors"
            }
          ]
        });


        // Listen to the feature form's submit event.
        // Update feature attributes shown in the form.
        featureForm.on("submit", function() {
          if (editFeature) {
            // Grab updated attributes from the form.
            const updated = featureForm.getValues();

            // Loop through updated attributes and assign
            // the updated values to feature attributes.
            Object.keys(updated).forEach(function(name) {
              editFeature.attributes[name] = updated[name];
            });

            // Setup the applyEdits parameter with updates.
            const edits = {
              updateFeatures: [editFeature]
            };
            applyEditsToIncidents(edits);
            //applyEditsToGraphics(edits);
            document.getElementById("viewDiv").style.cursor = "auto";
          }
        });

        // Check if the user clicked on the existing feature
        selectExistingFeature();
        selectExistingGraphicsFeature();

        // The FeatureTemplates widget uses the 'addTemplatesDiv'
        // element to display feature templates from incidentsLayer
        const templates = new FeatureTemplates({
          container: "addTemplatesDiv",
          layers: [geojsonLayer]
        });

        // Listen for when a template item is selected
        templates.on("select", function(evtTemplate) {
          // Access the template item's attributes from the event's
          // template prototype.
          attributes = evtTemplate.template.prototype.attributes;
          unselectFeature();
          document.getElementById("viewDiv").style.cursor = "crosshair";

          // With the selected template item, listen for the view's click event and create feature
          const handler = view.on("click", function(event) {
            // remove click event handler once user clicks on the view
            // to create a new feature
            handler.remove();
            event.stopPropagation();
            featureForm.feature = null;

            if (event.mapPoint) {
              point = event.mapPoint.clone();
              point.z = undefined;
              point.hasZ = false;

              // Create a new feature using one of the selected
              // template items.
              
              editFeature = new Graphic({
                geometry: point,
                //geometry: polygon,
                attributes: {name: "My Design",
                BldgType: "mixed",
                height:20}
                //type: event.graphic.geometry.type}
              });

              // Setup the applyEdits parameter with adds.
              const edits = {
                addFeatures: [editFeature]
              };
              applyEditsToIncidents(edits);
              //applyEditsToGraphics(edits);
              document.getElementById("viewDiv").style.cursor = "auto";
            } else {
              console.error("event.mapPoint is not defined");
            }
          });
        });

        // Call FeatureLayer.applyEdits() with specified params.
        function applyEditsToIncidents(params) {
          // unselectFeature();
          geojsonLayer
            .applyEdits(params)
            .then(function(editsResult) {
              // Get the objectId of the newly added feature.
              // Call selectFeature function to highlight the new feature.
              if (
                editsResult.addFeatureResults.length > 0 ||
                editsResult.updateFeatureResults.length > 0
              ) {
                unselectFeature();
                let objectId;
                if (editsResult.addFeatureResults.length > 0) {
                  objectId = editsResult.addFeatureResults[0].objectId;
                } else {
                  featureForm.feature = null;
                  objectId = editsResult.updateFeatureResults[0].objectId;
                }
                selectFeature(objectId);
            
                if (addFeatureDiv.style.display === "block") {
                  toggleEditingDivs("none", "block");
                }
              }
              // show FeatureTemplates if user deleted a feature
              else if (editsResult.deleteFeatureResults.length > 0) {
                toggleEditingDivs("block", "none");
              }
            })
            .catch(function(error) {
              console.log("===============================================");
              console.error(
                "[ applyEdits ] FAILURE: ",
                error.code,
                error.name,
                error.message
              );
              console.log("error = ", error);
            });
        }

        // Call FeatureLayer.applyEdits() with specified params.
        function applyEditsToGraphics(params) {
          // unselectFeature();
          gLayer
            .applyEdits(params)
            .then(function(editsResult) {
              // Get the objectId of the newly added feature.
              // Call selectFeature function to highlight the new feature.
              if (
                editsResult.addFeatureResults.length > 0 ||
                editsResult.updateFeatureResults.length > 0
              ) {
                unselectFeature();
                let objectId;
                if (editsResult.addFeatureResults.length > 0) {
                  objectId = editsResult.addFeatureResults[0].objectId;
                } else {
                  featureForm.feature = null;
                  objectId = editsResult.updateFeatureResults[0].objectId;
                }
                selectFeature(objectId);
                if (addFeatureDiv.style.display === "block") {
                  toggleEditingDivs("none", "block");
                }
              }
              // show FeatureTemplates if user deleted a feature
              else if (editsResult.deleteFeatureResults.length > 0) {
                toggleEditingDivs("block", "none");
              }
            })
            .catch(function(error) {
              console.log("===============================================");
              console.error(
                "[ applyEdits ] FAILURE: ",
                error.code,
                error.name,
                error.message
              );
              console.log("error = ", error);
            });
        }
        // Check if a user clicked on an incident feature.
        function selectExistingFeature() {
          view.on("click", function(event) {
            // clear previous feature selection
            unselectFeature();
            if (
              document.getElementById("viewDiv").style.cursor != "crosshair"
            ) {
              view.hitTest(event).then(function(response) {
                // If a user clicks on an incident feature, select the feature.
                if (response.results.length === 0) {
                  toggleEditingDivs("block", "none");
                } else if (
                  response.results[0].graphic &&
                  response.results[0].graphic.layer.id == "incidentsLayer"
                ) {
                  if (addFeatureDiv.style.display === "block") {
                    toggleEditingDivs("none", "block");
                  }
                  selectFeature(
                    response.results[0].graphic.attributes[
                    geojsonLayer.objectIdField
                    ]
                  );
                }
              });
            }
          });
        }

           // Check if a user clicked on an graphics feature.
           function selectExistingGraphicsFeature() {
          view.on("click", function(event) {
            // clear previous feature selection
            unselectFeature();
            if (
              document.getElementById("viewDiv").style.cursor != "crosshair"
            ) {
              view.hitTest(event).then(function(response) {
                // If a user clicks on an incident feature, select the feature.
                if (response.results.length === 0) {
                  toggleEditingDivs("block", "none");
                } else if (
                  response.results[0].graphic &&
                  response.results[0].graphic.layer.id == "gLayer"
                ) {
                  if (addFeatureDiv.style.display === "block") {
                    toggleEditingDivs("none", "block");
                  }
                  selectFeature(
                    response.results[0].graphic.attributes[
                    gLayer.objectIdField
                    ]
                  );
                }
              });
            }
          });
        }

        // Highlights the clicked feature and display
        // the feature form with the incident's attributes.
        function selectFeature(objectId) {
          // query feature from the server
          geojsonLayer
            .queryFeatures({
              objectIds: [objectId],
              outFields: ["*"],
              //outFields: ["BldgType","height"],
              returnGeometry: true
            })
            .then(function(results) {
              if (results.features.length > 0) {
                editFeature = results.features[0];

                // display the attributes of selected feature in the form
                featureForm.feature = editFeature;

                // highlight the feature on the view
                view.whenLayerView(editFeature.layer).then(function(layerView) {
                  highlight = layerView.highlight(editFeature);
                });
              }
            });
        }

        // Expand widget for the editArea div.
        const editExpand = new Expand({
          expandIconClass: "esri-icon-edit",
          expandTooltip: "Expand Edit",
          expanded: true,
          view: view,
          content: document.getElementById("editArea")
        });

        view.ui.add(editExpand, "top-right");
        // input boxes for the attribute editing
        const addFeatureDiv = document.getElementById("addFeatureDiv");
        const attributeEditing = document.getElementById("featureUpdateDiv");

        // Controls visibility of addFeature or attributeEditing divs
        function toggleEditingDivs(addDiv, attributesDiv) {
          addFeatureDiv.style.display = addDiv;
          attributeEditing.style.display = attributesDiv;

          // document.getElementById(
          //   "updateInstructionDiv"
          // ).style.display = addDiv;
        }

        // Remove the feature highlight and remove attributes
        // from the feature form.
        function unselectFeature() {
          if (highlight) {
            highlight.remove();
          }
        }
        /**************************************************


        ***************************************************/
        // Update attributes of the selected feature.
        document.getElementById("btnUpdate").onclick = function() {
          // Fires feature form's submit event.
          featureForm.submit();
        };

        // Delete the selected feature. ApplyEdits is called
        // with the selected feature to be deleted.
        document.getElementById("btnDelete").onclick = function() {
          // setup the applyEdits parameter with deletes.
          const edits = {
            deleteFeatures: [editFeature]
          };
          applyEditsToIncidents(edits);
          //applyEditsToGraphics(edits);
          document.getElementById("viewDiv").style.cursor = "auto";
        };



        /************************
         * query by geometry
         * ************************/
        // add a GraphicsLayer for the sketches and the buffer
        const sketchLayer = new GraphicsLayer();
        const bufferLayer = new GraphicsLayer();
        view.map.addMany([bufferLayer, sketchLayer]);
        let sceneLayer = null;
        let sceneLayerView = null;
        let bufferSize = 0;

        //Assign scene layer once webscene is loaded and initialize UI
        // view.map.load().then(function() {
        //   sceneLayer = view.map.layers.find(function(layer) {
        //     return layer.title === "geojson";
        //   });
        //   //sceneLayer.outFields = ["buildingMaterial", "yearCompleted"];

        //   view.whenLayerView(sceneLayer).then(function(layerView) {
        //     if (layer.type === "geojson") {
        //     sceneLayerView = layerView;
        //     queryDiv.style.display = "block";}
        //   });
        // });
        
        view.map.load().then(function() {
          sceneLayer = view.map.layers;
        //     return layer.title === "geojson";
        //   });
          //sceneLayer.outFields = ["buildingMaterial", "yearCompleted"];
          // loop through webmap's operational layers
          view.map.layers.forEach(function(layer, index) {
            view
              .whenLayerView(layer)
              .then(function(layerView) {
                // if (layer.type === "geojson") {
                //   geojsonLayerView = layerView;
                // }
                if (layer.type === "geojson" || layer.id === "gLayer") {
                  sceneLayerView = layerView;
                  // queryDiv.style.display = "block";
                }
              })
              .catch(console.error);
          });
        });

        view.watch("updating", function(updating) {
          if (!updating) {
            runQuery();
          }
        });

        view.ui.add([queryDiv], "top-left");
        view.ui.add([resultDiv], "bottom-right");

        // use SketchViewModel to draw polygons that are used as a query
        let sketchGeometry = null;
        const sketchViewModel = new SketchViewModel({
          layer: sketchLayer,
          // defaultUpdateOptions: {
          //   tool: "reshape",
          //   toggleToolOnClick: false
          // },
          view: view,
          pointSymbol: {
            type: "simple-marker",
            style: "circle",
            size: 10,
            color: [255, 255, 255, 0.8],
            outline: {
              color: [211, 132, 80, 0.7],
              size: 100
            }
          },
          // polylineSymbol: {
          //   type: "simple-line",
          //   color: [211, 132, 80, 0.7],
          //   width: 6
          // },
          polygonSymbol: {
            type: "polygon-3d",
            symbolLayers: [
              {
                type: "fill",
                material: {
                  color: [255, 255, 255, 0.8]
                },
                outline: {
                  color: [211, 132, 80, 0.7],
                  size: "10px"
                }
              }
            ]
          }
        });

        sketchViewModel.on("create", function(event) {
          if (event.state === "complete") {
            sketchGeometry = event.graphic.geometry;
            runQuery();
          }
        });

        sketchViewModel.on("update", function(event) {
          if (event.state !== "cancel" && event.graphics.length) {
            sketchGeometry = event.graphics[0].geometry;
            runQuery();
          }
        });
        // draw geometry buttons - use the selected geometry to sktech
        document
          .getElementById("point-geometry-button")
          .addEventListener("click", geometryButtonsClickHandler);
        // document
        //   .getElementById("line-geometry-button")
        //   .addEventListener("click", geometryButtonsClickHandler);
        document
          .getElementById("polygon-geometry-button")
          .addEventListener("click", geometryButtonsClickHandler);
        function geometryButtonsClickHandler(event) {
          const geometryType = event.target.value;
          clearGeometry();
          sketchViewModel.create(geometryType);
        }

        const bufferNumSlider = new Slider({
          container: "bufferNum",
          min: 0,
          max: 800,
          steps: 100,
          labelsVisible: true,
          precision: 0,
          labelFormatFunction: function(value, type) {
            return value.toString() + "m";
          },
          values: [100]
        });
        // get user entered values for buffer
        bufferNumSlider.on(
          ["thumb-change", "thumb-drag"],
          bufferVariablesChanged
        );
        function bufferVariablesChanged(event) {
          bufferSize = event.value;
          runQuery();
        }
        // Clear the geometry and set the default renderer
        document
          .getElementById("clearGeometry")
          .addEventListener("click", clearGeometry);

        // Clear the geometry and set the default renderer
        function clearGeometry() {
          sketchGeometry = null;
          sketchViewModel.cancel();
          sketchLayer.removeAll();
          bufferLayer.removeAll();
          clearHighlighting();
          clearCharts();
          resultDiv.style.display = "none";
        }

        // set the geometry query on the visible SceneLayerView
        var debouncedRunQuery = promiseUtils.debounce(function() {
          if (!sketchGeometry) {
            return;
          }

          resultDiv.style.display = "block";
          updateBufferGraphic(bufferSize);
          return promiseUtils.eachAlways([
            queryStatistics(),
            updateSceneLayer()
          ]);
        });

        function runQuery() {
          debouncedRunQuery().catch((error) => {
            if (error.name === "AbortError") {
              return;
            }

            console.error(error);
          });
        }

        // Set the renderer with objectIds
        var highlightHandle = null;
        function clearHighlighting() {
          if (highlightHandle) {
            highlightHandle.remove();
            highlightHandle = null;
          }
        }

        function highlightBuildings(objectIds) {
          // Remove any previous highlighting
          clearHighlighting();
          const objectIdField = sceneLayer.objectIdField;
          //console.log(objectIdField);
          document.getElementById("count").innerHTML = objectIds.length;

          highlightHandle = sceneLayerView.highlight(objectIds);
        }

        // update the graphic with buffer
        function updateBufferGraphic(buffer) {
          // add a polygon graphic for the buffer
          if (buffer > 0) {
            var bufferGeometry = geometryEngine.geodesicBuffer(
              sketchGeometry,
              buffer,
              "meters"
            );
            if (bufferLayer.graphics.length === 0) {
              bufferLayer.add(
                new Graphic({
                  geometry: bufferGeometry,
                  symbol: sketchViewModel.polygonSymbol
                })
              );
            } else {
              bufferLayer.graphics.getItemAt(0).geometry = bufferGeometry;
            }
          } else {
            bufferLayer.removeAll();
          }
        }

        function updateSceneLayer() {
          const query = sceneLayerView.createQuery();
          query.geometry = sketchGeometry;
          query.distance = bufferSize;
          return sceneLayerView.queryObjectIds(query).then(highlightBuildings);
        }

        document.getElementById("queryDiv").style.display = "block";

        /**********************************QUERY BY DENSITY***********************************/
        let density;
        const densitySlider = new Slider({
          container: "density",
          min: 0,
          max: 200,
          steps: 1,
          values:[20,100],
          labelsVisible: true,
          rangeLabelsVisible: true,
        });
        //console.log(densitySlider.value)
        densitySlider.on("thumb-drag", function(event) {
          density = event.value;
        });
        var highlight_den;
        // highlight features based on a layer query result
        // this workflow is valid only if the scene layer has an associated feature layer
        
    //     document
    //         .getElementById("query-quakes")
    //         .addEventListener("click", function() {
            
    //         view.whenLayerView(sceneLayer).then(function(layerView){
    //         var query = sceneLayer.createQuery();
    //         query.where = "height >=" + densitySlider.values[0];
    //          query.outFields = ["BldgType","height"];

    //         sceneLayer.queryFeatures(query).then(function(result){
    //             if (highlight_den) {
    //             highlight_den.remove();
    //             }
    //         highlight_den = layerView.highlight(result.features);
    //         })
    //     });
    //    });
        
        document
            .getElementById("query-quakes")
            .addEventListener("click", function() {
            queryDensity().then(displayResults);
            //geojsonLayer.queryFeatures(query)
        });

        document
            .getElementById("query-quakes-clear")
            .addEventListener("click", function() {
                clearDensity();
            //geojsonLayer.queryFeatures(query)
        });

        function clearDensity(){
            highlight_den.remove();
        }

        function queryDensity() {
        var query = geojsonLayer.createQuery()
            query.where = "UnitsRes >=" + densitySlider.values[0];
            query.returnGeometry = true;
            //query.where = "height >= 40"
            //density_query.geometry = density_geo;
            query.outFields = ["BldgType","height","UnitsRes"];
        return geojsonLayer.queryObjectIds(query);
        }

        function displayResults(results) {
          //resultsLayer.removeAll();
          //var features = results.features
        //   var features = results.features.map(function(graphic) {
        //     // graphic.symbol = {
        //     // type: "simple-fill", // autocasts as new SimpleMarkerSymbol()
        //     // color: [ 51,51, 204, 0.9 ],
        //     // style: "solid",
        //     // outline: {  // autocasts as new SimpleLineSymbol()
        //     //     color: "white",
        //     //     width:  10}
        //     // };
        //     graphic.symbol= extrudedPolygon;
        //     return graphic;
        //   });
        //var feature = results.features[0];
        // use the objectID to highlight the feature
        // highlightSelect = sceneLayerView.highlight(
        // feature.attributes["OBJECTID"]
        // );
          if(highlight_den){
              highlight_den.remove();
          }
        //   view.whenLayerView(results.features).then(function(layerView) {
        //     highlight_den = layerView.highlight(results.features);}

          highlight_den = sceneLayerView.highlight(results) //highlight the query results
          console.log(highlight_den)
          var numQuakes = results.length;
          console.log(results);
          document.getElementById("results").innerHTML =
            numQuakes + " buildings found";
          //resultsLayer.addMany(features);
          geojsonLayer.queryFeatures().then(function(featureset){
            var feature_json = featureset.toJSON()
            console.log(feature_json);
        });
        }

        // geojsonLayer.queryFeatures().then(function(featureset){
        //     var feature_json = featureset.toJSON()
        //     console.log(feature_json);
        // })
       

       // // query all features from the oil and gas wells layer
        // view.when(function() {
        // return wellsLayer.when(function() {
        //     var query = geojsonLayer.createQuery();
        //     return wellsLayer.queryFeatures(query);
        // });
        // });

        /**********************************CREATE CHARTS***********************************/
        var yearChart = null;
        var materialChart = null;

        function queryStatistics() {
             const statDefinitions = [
            {
              onStatisticField:
                "CASE WHEN BldgType = 'residential' THEN 1 ELSE 0 END",
              outStatisticFieldName: "material_residential",
              statisticType: "sum"
            },
            {
              onStatisticField:
                "CASE WHEN BldgType = 'commercial' THEN 1 ELSE 0 END",
              outStatisticFieldName: "material_commercial",
              statisticType: "sum"
            },
            {
              onStatisticField:
                "CASE WHEN BldgType = 'office' THEN 1 ELSE 0 END",
              outStatisticFieldName: "material_office",
              statisticType: "sum"
            },
            {
              onStatisticField:
                "CASE WHEN BldgType = 'mixed' THEN 1 ELSE 0 END",
              outStatisticFieldName: "material_mixed",
              statisticType: "sum"
            },
            {
              onStatisticField:
                "CASE WHEN BldgType = 'industrial' THEN 1 ELSE 0 END",
              outStatisticFieldName: "material_industrial",
              statisticType: "sum"
            },
            {
              onStatisticField:
                "CASE WHEN BldgType = 'openspace' THEN 1 ELSE 0 END",
              outStatisticFieldName: "material_openspace",
              statisticType: "sum"
            },
            {
              onStatisticField:
                "CASE WHEN BldgType = 'health' THEN 1 ELSE 0 END",
              outStatisticFieldName: "material_health",
              statisticType: "sum"
            },
            {
              onStatisticField:
                "CASE WHEN BldgType = 'cultural' THEN 1 ELSE 0 END",
              outStatisticFieldName: "material_cultural",
              statisticType: "sum"
            },
            {
              onStatisticField:
                "CASE WHEN BldgType = 'education' THEN 1 ELSE 0 END",
              outStatisticFieldName: "material_education",
              statisticType: "sum"
            }
          ];
      

          const query = sceneLayerView.createQuery();
          query.geometry = sketchGeometry;
          query.distance = bufferSize;
          query.outStatistics = statDefinitions;

          return sceneLayerView.queryFeatures(query).then(function(result) {
            const allStats = result.features[0].attributes;
            //console.log(allStats);
            updateChart(materialChart, [
            //allStats.material_residential,
            allStats.material_mixed,
            allStats.material_commercial,
            allStats.material_office,
            allStats.material_industrial,
            allStats.material_openspace,
            allStats.material_health,
            allStats.material_cultural,
            allStats.material_education,
            ]);
            // updateChart(yearChart, [
            //   allStats.year_1850,
            //   allStats.year_1900,
            //   allStats.year_1925,
            //   allStats.year_1950,
            //   allStats.year_1975,
            //   allStats.year_2000
            // ]);
          }, console.error);
        };

        // Updates the given chart with new data
        function updateChart(chart, dataValues) {
          chart.data.datasets[0].data = dataValues;
          chart.update();
        }

        function createYearChart() {
          const yearCanvas = document.getElementById("year-chart");
          yearChart = new Chart(yearCanvas.getContext("2d"), {
            type: "horizontalBar",
            data: {
              labels: [
                "1850-1899",
                "1900-1924",
                "1925-1949",
                "1950-1974",
                "1975-1999",
                "2000-2015"
              ],
              datasets: [
                {
                  label: "Build year",
                  backgroundColor: "#149dcf",
                  stack: "Stack 0",
                  data: [0, 0, 0, 0, 0, 0]
                }
              ]
            },
            options: {
              responsive: false,
              legend: {
                display: false
              },
              title: {
                display: true,
                text: "Build year"
              },
              scales: {
                xAxes: [
                  {
                    stacked: true,
                    ticks: {
                      beginAtZero: true,
                      precision: 0
                    }
                  }
                ],
                yAxes: [
                  {
                    stacked: true
                  }
                ]
              }
            }
          });
        }
        function createMaterialChart() {
          const materialCanvas = document.getElementById("material-chart");
          materialChart = new Chart(materialCanvas.getContext("2d"), {
            type: "horizontalBar",
            data: {
              labels: ["Mixed", "Commercial","Office","Industrial", "Openspace","Health","Cultural","Education"],
              datasets: [
                {
                  backgroundColor: [
                    //"#FDB809",
                    "#FC8553",
                    "#F3B3B1",
                    "#E01B27",
                    "#983EBC",
                    "#BCD08D",
                    "#8bbdd9",
                    "#026aa7",
                    "#0b54ff"
                  ],
                  borderWidth: 0,
                  data: [0,0,0,0,0,0,0,0]
                }
              ]
            },
            options: {
              responsive: false,
              //cutoutPercentage: 35,
              legend: {
                display: false,
                //position: "bottom"
              },
              title: {
                display: true,
                text: "Accessibility"
              }
            }
          });
        }

        function clearCharts() {
          updateChart(materialChart, [0, 0, 0, 0,0,0, 0]);
          //updateChart(yearChart, [0, 0, 0, 0, 0, 0]);
          document.getElementById("count").innerHTML = 0;
        }

        //createYearChart();
        createMaterialChart();
        var legend = new Legend({
          view: view
        });

        //view.ui.add(legend, "bottom-left");
      });
    </script>
  </head>

  <body>
    <div id="viewDiv"></div>
    <div id="sketchPanel" class="esri-widget">
        <button id="drawbuilding" data-type="polygon" class="esri-button">
          Draw a building
        </button>
      </div>
    <div id="editArea" class="editArea-container esri-widget--panel">
        <div id="addFeatureDiv" style="display:block;">
          <h3 class="list-heading">Update Features</h3>
          <ul style="font-size: 13px; padding-left: 1.5em;">
            <!-- <li>Select template from the list</li>
            <li>Click on the map to create a new feature</li> -->
            <li>Update associated attribute data</li>
            <li>Click <i>Update building Info</i></li>
          </ul>
          <!-- <div id="addTemplatesDiv" style="background:#fff;"></div> -->
        </div>
  
        <div id="featureUpdateDiv" style="display:none; margin-top: 1em;">
          <h3 class="list-heading">Enter the building information</h3>
          <div id="attributeArea">
            <div id="formDiv"></div>
            <input
              type="button"
              class="esri-button"
              value="Update building info"
              id="btnUpdate"
            />
          </div>
          <br />
          <div id="deleteArea">
            <input
              type="button"
              class="esri-button"
              value="Delete building"
              id="btnDelete"
            />
          </div>
        </div>
  
        <!-- <div id="updateInstructionDiv" style="text-align:center; display:block">
          <p class="or-wrap"><span class="or-text">Or</span></p>
          <p id="selectHeader">Select a building to edit or delete.</p>
        </div> -->
      </div>
    <div id="queryDiv" class="esri-widget">
      <b>Query by geometry</b><br />
      <br />Draw a geometry to query by:
      <div class="geometry-options">
        <button
          class="esri-widget--button esri-icon-map-pin geometry-button"
          id="point-geometry-button"
          value="point"
          title="Query by point"
        ></button>
        <!-- <button
          class="esri-widget--button esri-icon-polyline geometry-button"
          id="line-geometry-button"
          value="polyline"
          title="Query by line"
        ></button> -->
        <button
          class="esri-widget--button esri-icon-polygon geometry-button"
          id="polygon-geometry-button"
          value="polygon"
          title="Query by polygon"
        ></button>
      </div>
      <br />
      <div class="tooltip">
        <label for="bufferNum">Set a geometry buffer size:</label>
        <div id="bufferNum"></div>
      </div>
      <br />
      <button class="esri-button" id="clearGeometry" type="button">
        Clear
      </button>
    </div>

    <div id="resultDiv" class="esri-widget">
      <div class="count">
        Selected Buildings:
        <div class="count" id="count">0</div>
      </div>
      <div class="charts">
        <!-- <div>
          <canvas id="year-chart" height="250" width="260" />
        </div> -->
        <div>
          <canvas id="material-chart" width="250" height="300" />
        </div>
      </div>
    </div>

    <div id="infoDiv" class="esri-widget">
        <b>Query by density</b><br />
        Residential Unit Per Building
    <br/>
        <div id="density" class="slider"></div>
        <button id="query-quakes" class="esri-widget">Query</button>
        <button id="query-quakes-clear" class="esri-widget">Clear</button>
        <div id="results" class="esri-widget"></div>
    </div>
  </body>
</html>

